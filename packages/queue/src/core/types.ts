/**
 * @eclaire/queue/core - Zero-dependency core types for the queue system
 *
 * These interfaces define the contract that all queue drivers must implement.
 * They are designed to be generic and reusable across different projects.
 *
 * ## Time Values Convention
 *
 * All time duration values in this package are in **milliseconds** unless
 * explicitly documented otherwise. This includes:
 * - `delay`, `timeout`, `lockDuration`, `heartbeatInterval`, `pollInterval`
 * - Backoff delays and retry delays
 * - Any function parameter or return value representing a duration
 *
 * Timestamps (Date objects) are used for absolute points in time.
 */

// ============================================================================
// Job Types
// ============================================================================

/**
 * Represents a job in the queue system
 */
export interface Job<T = unknown> {
  /** Unique job identifier (generated by the queue system) */
  id: string;

  /** Idempotency key for deduplication (optional, user-provided) */
  key?: string;

  /** Queue name (e.g., "bookmark-processing", "image-resize") */
  queue: string;

  /** Job payload data */
  data: T;

  /** Current job status */
  status: JobStatus;

  /** Job priority (higher = processed first) */
  priority: number;

  /** Number of times this job has been attempted */
  attempts: number;

  /** Maximum retry attempts before permanent failure */
  maxAttempts: number;

  /** When the job was created */
  createdAt: Date;

  /** When the job is scheduled to run (null = immediately) */
  scheduledFor?: Date;

  /** When the job was last updated */
  updatedAt: Date;

  // ---- Multi-stage progress tracking (optional) ----

  /** Processing stages for multi-stage jobs */
  stages?: JobStage[];

  /** Name of the stage currently being processed */
  currentStage?: string;

  /** Overall progress across all stages (0-100) */
  overallProgress?: number;

  /** Application-specific metadata (e.g., userId, assetType, assetId) */
  metadata?: Record<string, unknown>;
}

/**
 * Job status values
 */
export type JobStatus =
  | "pending" // Ready to be processed
  | "processing" // Currently being processed by a worker
  | "completed" // Successfully completed
  | "failed" // Permanently failed (exhausted retries)
  | "retry_pending"; // Waiting for retry after failure

// ============================================================================
// Multi-Stage Progress Tracking
// ============================================================================

/**
 * Status values for individual processing stages
 */
export type JobStageStatus = "pending" | "processing" | "completed" | "failed";

/**
 * Represents a single stage in a multi-stage job
 *
 * Jobs can optionally have multiple stages to track granular progress.
 * For example, a bookmark processing job might have stages:
 * ["validation", "content_extraction", "ai_tagging", "storage"]
 */
export interface JobStage {
  /** Stage identifier (e.g., "validation", "content_extraction") */
  name: string;

  /** Current status of this stage */
  status: JobStageStatus;

  /** Progress within this stage (0-100) */
  progress: number;

  /** When this stage started processing */
  startedAt?: Date;

  /** When this stage completed (success or failure) */
  completedAt?: Date;

  /** Error message if stage failed */
  error?: string;

  /** Artifacts produced by this stage (e.g., file paths, counts) */
  artifacts?: Record<string, unknown>;
}

// ============================================================================
// Event Callbacks (for SSE/real-time updates)
// ============================================================================

/**
 * Callbacks for job lifecycle events
 *
 * These allow applications to receive real-time notifications about job progress
 * without polling. Typically wired to SSE or WebSocket publishing.
 *
 * All callbacks receive the job metadata for routing (e.g., userId for SSE targeting).
 */
export interface JobEventCallbacks {
  /** Called when a stage begins processing */
  onStageStart?: (
    jobId: string,
    stage: string,
    metadata?: Record<string, unknown>,
  ) => void;

  /** Called when stage progress is updated (may be called frequently) */
  onStageProgress?: (
    jobId: string,
    stage: string,
    percent: number,
    metadata?: Record<string, unknown>,
  ) => void;

  /** Called when a stage completes successfully */
  onStageComplete?: (
    jobId: string,
    stage: string,
    artifacts?: Record<string, unknown>,
    metadata?: Record<string, unknown>,
  ) => void;

  /** Called when a stage fails */
  onStageFail?: (
    jobId: string,
    stage: string,
    error: string,
    metadata?: Record<string, unknown>,
  ) => void;

  /** Called when the entire job completes successfully */
  onJobComplete?: (
    jobId: string,
    metadata?: Record<string, unknown>,
  ) => void;

  /** Called when the entire job fails permanently */
  onJobFail?: (
    jobId: string,
    error: string,
    metadata?: Record<string, unknown>,
  ) => void;
}

/**
 * Backoff strategy for retries
 */
export interface BackoffStrategy {
  /** Type of backoff calculation */
  type: "exponential" | "linear" | "fixed";

  /** Base delay in milliseconds */
  delay: number;

  /** Maximum delay cap in milliseconds */
  maxDelay?: number;
}

/**
 * Options when enqueuing a job
 */
export interface JobOptions {
  /** Idempotency key - if a job with this key exists, it will be updated instead of duplicated */
  key?: string;

  /** Job priority (higher = processed first, default: 0) */
  priority?: number;

  /** Delay in milliseconds before the job becomes available */
  delay?: number;

  /** Specific time when the job should run */
  runAt?: Date;

  /** Maximum number of retry attempts (default: 3) */
  attempts?: number;

  /** Backoff strategy for retries */
  backoff?: BackoffStrategy;

  /**
   * Replace behavior when a job with the same key already exists:
   * - undefined (default): Always replace regardless of state (backward compatible)
   * - 'if_not_active': Throw JobAlreadyActiveError if existing job is in 'processing' state.
   *   Terminal states (completed/failed) are treated as "no job exists" - a fresh job is created.
   *   Pending/retry_pending jobs are updated with new payload and options.
   */
  replace?: "if_not_active";

  // ---- Multi-stage progress tracking (optional) ----

  /**
   * Initial stages for multi-stage progress tracking
   *
   * If provided, the job will be created with these stages initialized
   * in "pending" status. Workers can then use ctx.startStage() to begin each stage.
   *
   * @example
   * ```typescript
   * await client.enqueue('bookmark-processing', data, {
   *   initialStages: ['validation', 'content_extraction', 'ai_tagging'],
   * });
   * ```
   */
  initialStages?: string[];

  /**
   * Application-specific metadata stored with the job
   *
   * This is useful for storing routing information (e.g., userId for SSE targeting)
   * or domain-specific identifiers (e.g., assetType, assetId) without polluting
   * the job data payload.
   *
   * @example
   * ```typescript
   * await client.enqueue('bookmark-processing', { bookmarkId, url }, {
   *   metadata: { userId: 'user_123', assetType: 'bookmarks', assetId: bookmarkId },
   * });
   * ```
   */
  metadata?: Record<string, unknown>;
}

// ============================================================================
// Queue Client Interface
// ============================================================================

/**
 * Statistics about a queue
 */
export interface QueueStats {
  /** Jobs waiting to be processed */
  pending: number;

  /** Jobs currently being processed */
  processing: number;

  /** Successfully completed jobs */
  completed: number;

  /** Failed jobs (exhausted retries) */
  failed: number;

  /** Jobs waiting for retry */
  retryPending: number;
}

/**
 * Client interface for interacting with the queue
 *
 * This is the main interface for enqueuing jobs and managing the queue.
 * Both BullMQ and DB drivers implement this interface.
 */
export interface QueueClient {
  /**
   * Add a job to the queue
   *
   * @param queue - Queue name
   * @param data - Job payload
   * @param options - Optional job configuration
   * @returns The job ID
   *
   * @example
   * ```typescript
   * const jobId = await client.enqueue('bookmark-processing', {
   *   bookmarkId: 'bm_123',
   *   url: 'https://example.com',
   * }, {
   *   key: 'bookmark:bm_123',  // Idempotency key
   *   attempts: 3,
   *   backoff: { type: 'exponential', delay: 1000 },
   * });
   * ```
   */
  enqueue<T>(queue: string, data: T, options?: JobOptions): Promise<string>;

  /**
   * Cancel a pending job
   *
   * @param jobIdOrKey - Job ID or idempotency key
   * @returns true if the job was cancelled, false if not found or already processed
   */
  cancel(jobIdOrKey: string): Promise<boolean>;

  /**
   * Retry a failed job
   *
   * @param jobIdOrKey - Job ID or idempotency key
   * @returns true if the job was requeued, false if not found
   */
  retry(jobIdOrKey: string): Promise<boolean>;

  /**
   * Get job details by ID or key
   *
   * @param jobIdOrKey - Job ID or idempotency key
   * @returns Job details or null if not found
   */
  getJob(jobIdOrKey: string): Promise<Job | null>;

  /**
   * Get queue statistics
   *
   * @param queue - Optional queue name filter (all queues if not specified)
   * @returns Queue statistics
   */
  stats(queue?: string): Promise<QueueStats>;

  /**
   * Close the client and release resources
   */
  close(): Promise<void>;
}

// ============================================================================
// Worker Interface
// ============================================================================

/**
 * Context provided to job handlers during execution
 *
 * This provides a way for handlers to interact with the queue system
 * (heartbeat, logging, progress) without knowing the underlying driver.
 */
export interface JobContext<T = unknown> {
  /** The job being processed */
  job: Job<T>;

  /**
   * Extend the job lock to prevent timeout
   *
   * Call this periodically during long-running jobs to signal
   * that the worker is still alive and processing.
   */
  heartbeat(): Promise<void>;

  /**
   * Log a message associated with this job
   *
   * @param message - Message to log
   */
  log(message: string): void;

  /**
   * Report progress percentage (0-100)
   *
   * @param percent - Progress percentage
   */
  progress(percent: number): void;

  // ---- Multi-stage progress tracking methods ----

  /**
   * Initialize job with processing stages
   *
   * Call this at the start of job processing to define the stages.
   * Each stage will be created with "pending" status and 0 progress.
   *
   * @param stages - Array of stage names in processing order
   *
   * @example
   * ```typescript
   * await ctx.initStages(['validation', 'content_extraction', 'ai_tagging']);
   * ```
   */
  initStages(stages: string[]): Promise<void>;

  /**
   * Begin processing a stage
   *
   * Sets the stage status to "processing" and records the start time.
   * Triggers onStageStart callback if configured.
   *
   * @param stage - Stage name to start
   */
  startStage(stage: string): Promise<void>;

  /**
   * Update progress within a stage
   *
   * This is a lightweight operation that only triggers the onStageProgress
   * callback without persisting to the database (to avoid excessive writes).
   *
   * @param stage - Stage name
   * @param percent - Progress percentage (0-100)
   */
  updateStageProgress(stage: string, percent: number): Promise<void>;

  /**
   * Mark a stage as completed
   *
   * Sets the stage status to "completed", progress to 100, and records
   * the completion time. Optionally stores artifacts produced by this stage.
   *
   * @param stage - Stage name to complete
   * @param artifacts - Optional artifacts produced by this stage
   */
  completeStage(stage: string, artifacts?: Record<string, unknown>): Promise<void>;

  /**
   * Mark a stage as failed
   *
   * Sets the stage status to "failed" and records the error.
   * This does not automatically fail the entire job.
   *
   * @param stage - Stage name that failed
   * @param error - Error that caused the failure
   */
  failStage(stage: string, error: Error): Promise<void>;

  /**
   * Add additional stages to an existing job
   *
   * Useful when the full list of stages isn't known upfront and stages
   * are discovered during processing (e.g., dynamic workflows).
   *
   * @param stages - Additional stage names to add
   */
  addStages(stages: string[]): Promise<void>;
}

/**
 * Job handler function signature
 *
 * @param ctx - Job context with job data and utility methods
 * @throws RateLimitError - To reschedule without counting as failure
 * @throws RetryableError - To fail and retry if attempts remain
 * @throws PermanentError - To fail permanently without retry
 * @throws Error - Any other error is treated as retryable
 */
export type JobHandler<T = unknown> = (ctx: JobContext<T>) => Promise<void>;

/**
 * Worker configuration options
 */
export interface WorkerOptions {
  /** Number of concurrent jobs to process (default: 1) */
  concurrency?: number;

  /** Job lock duration in milliseconds (default: 300000 = 5 minutes) */
  lockDuration?: number;

  /** Heartbeat interval in milliseconds (default: 60000 = 1 minute) */
  heartbeatInterval?: number;

  /** Stalled job check interval in milliseconds (default: 30000 = 30 seconds) */
  stalledInterval?: number;
}

/**
 * Worker interface for processing jobs
 *
 * A worker is responsible for fetching jobs from the queue and processing them.
 */
export interface Worker {
  /** Start the worker */
  start(): Promise<void>;

  /** Stop the worker gracefully */
  stop(): Promise<void>;

  /** Check if the worker is currently running */
  isRunning(): boolean;
}

/**
 * Factory function type for creating workers
 */
export type WorkerFactory<T = unknown> = (
  queue: string,
  handler: JobHandler<T>,
  options?: WorkerOptions,
) => Worker;

// ============================================================================
// Scheduler Interface (for recurring jobs)
// ============================================================================

/**
 * Schedule configuration for recurring jobs
 */
export interface ScheduleConfig {
  /** Unique identifier for this schedule */
  key: string;

  /** Queue name to enqueue jobs to */
  queue: string;

  /** Cron expression (e.g., "0 * * * *" for hourly) */
  cron: string;

  /** Job payload template */
  data: unknown;

  /** Whether the schedule is active (default: true) */
  enabled?: boolean;

  /** Maximum number of occurrences (null = unlimited) */
  limit?: number;

  /** When the schedule should stop */
  endDate?: Date;

  /** Run immediately on creation (default: false) */
  immediately?: boolean;
}

/**
 * Scheduler interface for managing recurring jobs
 */
export interface Scheduler {
  /**
   * Create or update a recurring schedule
   *
   * @param config - Schedule configuration
   * @returns The schedule key
   */
  upsert(config: ScheduleConfig): Promise<string>;

  /**
   * Remove a schedule
   *
   * @param key - Schedule key
   * @returns true if removed, false if not found
   */
  remove(key: string): Promise<boolean>;

  /**
   * Get a schedule by key
   *
   * @param key - Schedule key
   * @returns The schedule config, or null if not found
   */
  get(key: string): Promise<ScheduleConfig | null>;

  /**
   * Enable or disable a schedule
   *
   * @param key - Schedule key
   * @param enabled - Whether to enable or disable
   */
  setEnabled(key: string, enabled: boolean): Promise<void>;

  /**
   * Get all schedules
   *
   * @param queue - Optional queue name filter
   */
  list(queue?: string): Promise<ScheduleConfig[]>;

  /**
   * Start the scheduler (begins processing schedules)
   */
  start(): Promise<void>;

  /**
   * Stop the scheduler
   */
  stop(): Promise<void>;
}

// ============================================================================
// Notification Interface (for horizontal scaling)
// ============================================================================

/**
 * Notification listener interface for waking workers
 *
 * Used for horizontal scaling - when a job is enqueued, all waiting
 * workers across instances should be notified.
 */
export interface NotifyListener {
  /**
   * Subscribe to job notifications for a queue
   *
   * @param name - Queue name
   * @param callback - Called when jobs are available
   */
  subscribe(name: string, callback: () => void): void;

  /**
   * Unsubscribe from notifications
   *
   * @param name - Queue name
   */
  unsubscribe(name: string): void;

  /**
   * Close the listener
   */
  close(): Promise<void>;
}

/**
 * Notification emitter interface for publishing job availability
 */
export interface NotifyEmitter {
  /**
   * Emit a notification that jobs are available
   *
   * @param name - Queue name
   */
  emit(name: string): Promise<void>;

  /**
   * Close the emitter
   */
  close(): Promise<void>;
}

// ============================================================================
// Logger Interface (minimal, for driver internal use)
// ============================================================================

/**
 * Minimal logger interface required by drivers
 *
 * This allows drivers to log without depending on a specific logging library.
 * Users can provide any logger that implements this interface.
 */
export interface QueueLogger {
  debug(obj: object, msg?: string): void;
  info(obj: object, msg?: string): void;
  warn(obj: object, msg?: string): void;
  error(obj: object, msg?: string): void;
}

// ============================================================================
// Configuration Types
// ============================================================================

/**
 * Base driver configuration
 */
export interface DriverConfig {
  /** Logger instance */
  logger: QueueLogger;
}
