/**
 * @eclaire/queue/core - Zero-dependency core types for the queue system
 *
 * These interfaces define the contract that all queue drivers must implement.
 * They are designed to be generic and reusable across different projects.
 *
 * ## Time Values Convention
 *
 * All time duration values in this package are in **milliseconds** unless
 * explicitly documented otherwise. This includes:
 * - `delay`, `timeout`, `lockDuration`, `heartbeatInterval`, `pollInterval`
 * - Backoff delays and retry delays
 * - Any function parameter or return value representing a duration
 *
 * Timestamps (Date objects) are used for absolute points in time.
 */

// ============================================================================
// Job Types
// ============================================================================

/**
 * Represents a job in the queue system
 */
export interface Job<T = unknown> {
  /** Unique job identifier (generated by the queue system) */
  id: string;

  /** Idempotency key for deduplication (optional, user-provided) */
  key?: string;

  /** Queue/job type name (e.g., "bookmark-processing", "image-resize") */
  name: string;

  /** Job payload data */
  data: T;

  /** Current job status */
  status: JobStatus;

  /** Job priority (higher = processed first) */
  priority: number;

  /** Number of times this job has been attempted */
  attempts: number;

  /** Maximum retry attempts before permanent failure */
  maxAttempts: number;

  /** When the job was created */
  createdAt: Date;

  /** When the job is scheduled to run (null = immediately) */
  scheduledFor?: Date;

  /** When the job was last updated */
  updatedAt: Date;
}

/**
 * Job status values
 */
export type JobStatus =
  | "pending" // Ready to be processed
  | "processing" // Currently being processed by a worker
  | "completed" // Successfully completed
  | "failed" // Permanently failed (exhausted retries)
  | "retry_pending"; // Waiting for retry after failure

/**
 * Backoff strategy for retries
 */
export interface BackoffStrategy {
  /** Type of backoff calculation */
  type: "exponential" | "linear" | "fixed";

  /** Base delay in milliseconds */
  delay: number;

  /** Maximum delay cap in milliseconds */
  maxDelay?: number;
}

/**
 * Options when enqueuing a job
 */
export interface JobOptions {
  /** Idempotency key - if a job with this key exists, it will be updated instead of duplicated */
  key?: string;

  /** Job priority (higher = processed first, default: 0) */
  priority?: number;

  /** Delay in milliseconds before the job becomes available */
  delay?: number;

  /** Specific time when the job should run */
  runAt?: Date;

  /** Maximum number of retry attempts (default: 3) */
  attempts?: number;

  /** Backoff strategy for retries */
  backoff?: BackoffStrategy;

  /**
   * Replace behavior when a job with the same key already exists:
   * - undefined (default): Always replace regardless of state (backward compatible)
   * - 'if_not_active': Throw JobAlreadyActiveError if existing job is in 'processing' state.
   *   Terminal states (completed/failed) are treated as "no job exists" - a fresh job is created.
   *   Pending/retry_pending jobs are updated with new payload and options.
   */
  replace?: "if_not_active";
}

// ============================================================================
// Queue Client Interface
// ============================================================================

/**
 * Statistics about a queue
 */
export interface QueueStats {
  /** Jobs waiting to be processed */
  pending: number;

  /** Jobs currently being processed */
  processing: number;

  /** Successfully completed jobs */
  completed: number;

  /** Failed jobs (exhausted retries) */
  failed: number;

  /** Jobs waiting for retry */
  retryPending: number;
}

/**
 * Client interface for interacting with the queue
 *
 * This is the main interface for enqueuing jobs and managing the queue.
 * Both BullMQ and DB drivers implement this interface.
 */
export interface QueueClient {
  /**
   * Add a job to the queue
   *
   * @param name - Queue/job type name
   * @param data - Job payload
   * @param options - Optional job configuration
   * @returns The job ID
   *
   * @example
   * ```typescript
   * const jobId = await client.enqueue('bookmark-processing', {
   *   bookmarkId: 'bm_123',
   *   url: 'https://example.com',
   * }, {
   *   key: 'bookmark:bm_123',  // Idempotency key
   *   attempts: 3,
   *   backoff: { type: 'exponential', delay: 1000 },
   * });
   * ```
   */
  enqueue<T>(name: string, data: T, options?: JobOptions): Promise<string>;

  /**
   * Cancel a pending job
   *
   * @param jobIdOrKey - Job ID or idempotency key
   * @returns true if the job was cancelled, false if not found or already processed
   */
  cancel(jobIdOrKey: string): Promise<boolean>;

  /**
   * Retry a failed job
   *
   * @param jobIdOrKey - Job ID or idempotency key
   * @returns true if the job was requeued, false if not found
   */
  retry(jobIdOrKey: string): Promise<boolean>;

  /**
   * Get job details by ID or key
   *
   * @param jobIdOrKey - Job ID or idempotency key
   * @returns Job details or null if not found
   */
  getJob(jobIdOrKey: string): Promise<Job | null>;

  /**
   * Get queue statistics
   *
   * @param name - Optional queue name filter (all queues if not specified)
   * @returns Queue statistics
   */
  stats(name?: string): Promise<QueueStats>;

  /**
   * Close the client and release resources
   */
  close(): Promise<void>;
}

// ============================================================================
// Worker Interface
// ============================================================================

/**
 * Context provided to job handlers during execution
 *
 * This provides a way for handlers to interact with the queue system
 * (heartbeat, logging, progress) without knowing the underlying driver.
 */
export interface JobContext<T = unknown> {
  /** The job being processed */
  job: Job<T>;

  /**
   * Extend the job lock to prevent timeout
   *
   * Call this periodically during long-running jobs to signal
   * that the worker is still alive and processing.
   */
  heartbeat(): Promise<void>;

  /**
   * Log a message associated with this job
   *
   * @param message - Message to log
   */
  log(message: string): void;

  /**
   * Report progress percentage (0-100)
   *
   * @param percent - Progress percentage
   */
  progress(percent: number): void;
}

/**
 * Job handler function signature
 *
 * @param ctx - Job context with job data and utility methods
 * @throws RateLimitError - To reschedule without counting as failure
 * @throws RetryableError - To fail and retry if attempts remain
 * @throws PermanentError - To fail permanently without retry
 * @throws Error - Any other error is treated as retryable
 */
export type JobHandler<T = unknown> = (ctx: JobContext<T>) => Promise<void>;

/**
 * Worker configuration options
 */
export interface WorkerOptions {
  /** Number of concurrent jobs to process (default: 1) */
  concurrency?: number;

  /** Job lock duration in milliseconds (default: 300000 = 5 minutes) */
  lockDuration?: number;

  /** Heartbeat interval in milliseconds (default: 60000 = 1 minute) */
  heartbeatInterval?: number;

  /** Stalled job check interval in milliseconds (default: 30000 = 30 seconds) */
  stalledInterval?: number;
}

/**
 * Worker interface for processing jobs
 *
 * A worker is responsible for fetching jobs from the queue and processing them.
 */
export interface Worker {
  /** Start the worker */
  start(): Promise<void>;

  /** Stop the worker gracefully */
  stop(): Promise<void>;

  /** Check if the worker is currently running */
  isRunning(): boolean;
}

/**
 * Factory function type for creating workers
 */
export type WorkerFactory<T = unknown> = (
  name: string,
  handler: JobHandler<T>,
  options?: WorkerOptions,
) => Worker;

// ============================================================================
// Scheduler Interface (for recurring jobs)
// ============================================================================

/**
 * Schedule configuration for recurring jobs
 */
export interface ScheduleConfig {
  /** Unique identifier for this schedule */
  key: string;

  /** Queue name to enqueue jobs to */
  name: string;

  /** Cron expression (e.g., "0 * * * *" for hourly) */
  cron: string;

  /** Job payload template */
  data: unknown;

  /** Whether the schedule is active (default: true) */
  enabled?: boolean;

  /** Maximum number of occurrences (null = unlimited) */
  limit?: number;

  /** When the schedule should stop */
  endDate?: Date;

  /** Run immediately on creation (default: false) */
  immediately?: boolean;
}

/**
 * Scheduler interface for managing recurring jobs
 */
export interface Scheduler {
  /**
   * Create or update a recurring schedule
   *
   * @param config - Schedule configuration
   * @returns The schedule key
   */
  upsert(config: ScheduleConfig): Promise<string>;

  /**
   * Remove a schedule
   *
   * @param key - Schedule key
   * @returns true if removed, false if not found
   */
  remove(key: string): Promise<boolean>;

  /**
   * Enable or disable a schedule
   *
   * @param key - Schedule key
   * @param enabled - Whether to enable or disable
   */
  setEnabled(key: string, enabled: boolean): Promise<void>;

  /**
   * Get all schedules
   *
   * @param name - Optional queue name filter
   */
  list(name?: string): Promise<ScheduleConfig[]>;

  /**
   * Start the scheduler (begins processing schedules)
   */
  start(): Promise<void>;

  /**
   * Stop the scheduler
   */
  stop(): Promise<void>;
}

// ============================================================================
// Notification Interface (for horizontal scaling)
// ============================================================================

/**
 * Notification listener interface for waking workers
 *
 * Used for horizontal scaling - when a job is enqueued, all waiting
 * workers across instances should be notified.
 */
export interface NotifyListener {
  /**
   * Subscribe to job notifications for a queue
   *
   * @param name - Queue name
   * @param callback - Called when jobs are available
   */
  subscribe(name: string, callback: () => void): void;

  /**
   * Unsubscribe from notifications
   *
   * @param name - Queue name
   */
  unsubscribe(name: string): void;

  /**
   * Close the listener
   */
  close(): Promise<void>;
}

/**
 * Notification emitter interface for publishing job availability
 */
export interface NotifyEmitter {
  /**
   * Emit a notification that jobs are available
   *
   * @param name - Queue name
   */
  emit(name: string): Promise<void>;

  /**
   * Close the emitter
   */
  close(): Promise<void>;
}

// ============================================================================
// Logger Interface (minimal, for driver internal use)
// ============================================================================

/**
 * Minimal logger interface required by drivers
 *
 * This allows drivers to log without depending on a specific logging library.
 * Users can provide any logger that implements this interface.
 */
export interface QueueLogger {
  debug(obj: object, msg?: string): void;
  info(obj: object, msg?: string): void;
  warn(obj: object, msg?: string): void;
  error(obj: object, msg?: string): void;
}

// ============================================================================
// Configuration Types
// ============================================================================

/**
 * Base driver configuration
 */
export interface DriverConfig {
  /** Logger instance */
  logger: QueueLogger;
}
