import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useCallback } from "react";
import { toast } from "sonner";
import { apiFetch } from "@/lib/frontend-api";
import type { NoteEntry } from "@/types/note";

// Transform backend note data to frontend format
// biome-ignore lint/suspicious/noExplicitAny: backend API response shape is not statically typed
const transformNoteData = (backendNote: any): NoteEntry => {
  return {
    id: backendNote.id,
    title: backendNote.title,
    content: backendNote.content,
    description: backendNote.description || null, // Auto-generated by backend
    dueDate: backendNote.dueDate,
    tags: backendNote.tags || [],
    userId: backendNote.userId || "",
    rawMetadata: backendNote.rawMetadata || null,
    originalMimeType: backendNote.originalMimeType || null,
    userAgent: backendNote.userAgent || null,
    createdAt: backendNote.createdAt || new Date().toISOString(),
    updatedAt: backendNote.updatedAt || new Date().toISOString(),
    processingStatus: backendNote.processingStatus || null, // From processing jobs
    reviewStatus: backendNote.reviewStatus || "pending",
    flagColor: backendNote.flagColor || null,
    isPinned: backendNote.isPinned || false,
    enabled: backendNote.enabled ?? true,
  };
};

/**
 * React Query hook for notes data fetching and management
 */
export function useNotes() {
  const queryClient = useQueryClient();

  const queryKey = ["notes"];

  // Main notes query - load all notes
  const {
    data: notes = [],
    isLoading,
    error,
    refetch,
  } = useQuery<NoteEntry[]>({
    queryKey,
    queryFn: async () => {
      // Call API without pagination to get all notes
      const response = await apiFetch("/api/notes?limit=9999");

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || "Failed to load notes");
      }

      const data = await response.json();

      // Handle different response structures - ensure we always get an array
      const notesArray = Array.isArray(data)
        ? data
        : data.notes || data.entries || [];

      // Transform backend data to frontend format
      return notesArray.map(transformNoteData);
    },
    staleTime: 5 * 60 * 1000, // 5 minutes (match global default)
    gcTime: 5 * 60 * 1000, // 5 minutes
  });

  // Create note mutation
  const createNoteMutation = useMutation({
    mutationFn: async (noteData: {
      title: string;
      content: string;
      dueDate?: string | null;
      tags: string[];
    }) => {
      const response = await apiFetch("/api/notes", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(noteData),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || "Failed to create note");
      }

      return response.json();
    },
    onSuccess: () => {
      // Invalidate and refetch notes
      queryClient.invalidateQueries({ queryKey });
    },
    onError: (error) => {
      toast.error(`Create failed: ${error.message}`);
    },
  });

  // Update note mutation
  const updateNoteMutation = useMutation({
    mutationFn: async ({
      id,
      updates,
    }: {
      id: string;
      updates: Partial<NoteEntry>;
    }) => {
      const response = await apiFetch(`/api/notes/${id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          title: updates.title,
          content: updates.content,
          dueDate: updates.dueDate,
          tags: updates.tags,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || "Failed to update note");
      }

      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
    onError: (error) => {
      toast.error(`Update failed: ${error.message}`);
    },
  });

  // Delete note mutation
  const deleteNoteMutation = useMutation({
    mutationFn: async (id: string) => {
      const response = await apiFetch(`/api/notes/${id}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || "Failed to delete note");
      }

      return;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
    onError: (error) => {
      toast.error(`Delete failed: ${error.message}`);
    },
  });

  // Upload note file mutation
  const uploadNoteMutation = useMutation({
    mutationFn: async (formData: FormData) => {
      const response = await apiFetch("/api/notes/upload", {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || "Failed to upload note file");
      }

      return response.json();
    },
    onSuccess: () => {
      // Invalidate and refetch notes
      queryClient.invalidateQueries({ queryKey });
    },
    onError: (error) => {
      toast.error(`Upload failed: ${error.message}`);
    },
  });

  // Helper functions
  const createNote = useCallback(
    (noteData: {
      title: string;
      content: string;
      dueDate?: string | null;
      tags: string[];
    }) => {
      return createNoteMutation.mutateAsync(noteData);
    },
    [createNoteMutation],
  );

  const updateNote = useCallback(
    (id: string, updates: Partial<NoteEntry>) => {
      return updateNoteMutation.mutateAsync({ id, updates });
    },
    [updateNoteMutation],
  );

  const deleteNote = useCallback(
    (id: string) => {
      return deleteNoteMutation.mutateAsync(id);
    },
    [deleteNoteMutation],
  );

  const uploadNote = useCallback(
    (formData: FormData) => {
      return uploadNoteMutation.mutateAsync(formData);
    },
    [uploadNoteMutation],
  );

  const refresh = useCallback(() => {
    refetch();
  }, [refetch]);

  return {
    // Data
    notes,

    // States
    isLoading,
    error,

    // Actions
    createNote,
    updateNote,
    deleteNote,
    uploadNote,
    refresh,

    // Mutation states
    isCreating: createNoteMutation.isPending,
    isUpdating: updateNoteMutation.isPending,
    isDeleting: deleteNoteMutation.isPending,
    isUploading: uploadNoteMutation.isPending,
  };
}

/**
 * Hook for a single note by ID
 */
export function useNote(id: string) {
  const queryKey = ["notes", id];

  const {
    data: note,
    isLoading,
    error,
    refetch,
  } = useQuery<NoteEntry>({
    queryKey,
    queryFn: async () => {
      const response = await apiFetch(`/api/notes/${id}`);

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || "Failed to load note");
      }

      const data = await response.json();
      return transformNoteData(data);
    },
    enabled: !!id,
    staleTime: 30000, // 30 seconds
  });

  return {
    note,
    isLoading,
    error,
    refresh: refetch,
  };
}
